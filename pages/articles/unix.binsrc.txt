====== методология защиты в мире UNIX ======
<sub>{{UNIX.binsrc.odt|Original file}}</sub>

крис касперски ака мыщъх no email

//…////today after sleepless 80 hours I have finished the contest! WOW, I am so satisfied, dunno what is better, sex or hacking (…сегодня после восьмидесяти бессонных часов я наконец-то хакнул это! Вау! Я////чувствую себя таким удовлетворенным, что начинаю сомневаться что лучше – секс или хакинг ////[////сразу видно//// ////–////наш человек////!//// Прим. КК////]////)//

//MoD//

**качество защитных механизмов в ****UNIX ****все еще остается на уровне слабого подобия левой руки и с ****Windows ****ей не тягаться. впрочем, качество хакерского инструментария под ****UNIX ****еще хуже, так что ****одно уровновешивает другое****.****даже плохенькая защита представляет собой большую проблему и дикую головную боль бессонных ночей. данная статья дает краткое представление о проблеме и рассказывает о наиболее популярных методах противодействия отладчикам и дизассемблерам.**

{{INLINETOC}}
===== введение =====

Программное обеспечение под UNIX далеко не всегда бесплатно и коммерческий софт успешно конкурирует с Open Source проектами, многие из которых распространяются за деньги ("свобода" еще не синоним халявы). Это и научные приложения, моделирующие движения звезд в галактиках, и корпоративные пакеты для работы с трехмерной графикой, и серверное обеспечение, и программные комплексы для управления производством, и т. д, и т. п. Все это не имеет никакого отношения ни к ПК, ни к "пиратству". Исследовательские институты и корпорации слишком дорожат своей репутацией, чтобы идти на открытый грабеж.

Поэтому-то, в мире UNIX так мало защит от несанкционированного копирования. Вот LINUX – другое дело! Ориентированная на домашних и офисных пользователей, она движется тропой варварского рынка (он же – "массовый"), населенного хакерами, пиратами и продвинутыми юзерами, способными постоять за свои права, наскоро скачав из сети свежепойманный крэк. Без достойной защиты здесь никуда! Без достойной защиты ваша программа вообще не будет продаваться.

===== разведка перед боем или в хакерском лагере у костра =====

С точки зрения хакера – UNIX полный отстой и фуфло, скажу я вам. Достойного инструментария нет и скоро не будет. Хачить приходится голыми руками, задницей и головой. Больше всего удручает отсутствие полноценного отладчика, если не Soft-Ice, то хотя бы OllyDbg. Мелочь типа дамперов памяти, различных там падчеров, автоматических распаковщиков упакованных файлов так же придется писать самостоятельно, поскольку живых представителей этой фауны в сети обнаружить не удалось. Лишь бесконечные кладбища заброшенных проектов…

Будем надеяться, что через несколько лет ситуация измениться (как известно спрос рождает предложение), а пока же ограничимся тем, что сделаем краткий образ существующего софта, пригодного для хакерствования (кстати говоря, защитные механизмы, особенно сложные, так же требует отладки).

==== отладчики ====

GDB – крос-платформеннй source-level отладчик, основанный на библиотеке ptrace (см. man ptrcae) и ориентированный преимущество на отладку приложений с исходными текстами. Для взлома подходит плохо, если подходит вообще. Поддерживает аппаратные точки останова на исполнение, но не чтение/запись памяти (однако, при запуске из-под VMWare они не срабатывают, а на голом железе я его не гонял). Не может брякать и модифицировать совместно используемую память (т. е. ls с его помощью вы вряд ли отладите!) Поиск в памяти отсутствует как таковой. Отказывается загружать файл с искаженной структурой или с отрезанной section table. Внешне представляет собой консольное приложение со сложной системой команд, полное описание который занимает порядка трехсот страниц убористого текста. При желании к отладчику можно прикрутить графическую оболочку (благо недостатка в них испытывать не приходится), однако, красивым интерфейсом кривое ядро не исправишь. За время своего существования, GDB успел обрасти густой шерстью антиотладочных приемов, многие из которых остаются актуальными и по сегодняшний день. Теперь о достоинствах. GDB бесплатен, распространяется по лицензии GNU (отсюда и название – Gnu DeBugger), входит в комплект поставки большинства UNIX'ов, и к тому же позволяет падчить исполняемый файл не выходя из отладчика.

Краткое руководство для начинающих: чтобы браякнуться на точке входа, необходимо предварительно определить ее адрес, для чего пригодиться штатная утилита objdump (только для незащищенных файлов!) или biew/IDA: "objdump file_name –f", затем загрузив отлаживаемую программу в GDB ("gdb –q file_name"), дать команду "break *0xXXXXXXXX", где "0xX" – стартовый адрес, а затем "run" для ее запуска на выполнение. Если все прошло успешно, GDB тут же остановится, передавая вам бразды правления. Если же нет, откройте файл в biew'е и внедрите в entry point точку останова (код CCh), предварительно сохранив в голове оригинальное содержимое и перезапустите отладчик, а после достижения точки останова восстановите ее содержимое (set {char} *0xXXXXXXXX = YY).

{{unix.binsrc_Image_0.png}}

**Рисунок 1 GDB за работой**

ALD:Assemble Language Debugger (http://ald.sourceforge.net/) – пронырливый source-level application-debugger с минимумом рычагов управления, ориентированный наотладку ассемблерных текстов и двоичных файлов. Основан на библиотеке ptrace со всеми отсюда вытекающими последствиями. В настоящее время работает только на x86-платформе, успешно компилируясь под следующие операционные системы: Linux, FreeBSD, NetBSDи OpenBSD. Поддерживает точки останова на выполнение, пошаговую/покомандную трассировку, просмотр/редактирование дампа, простор/изменение регистров, содержит простенький дизассемблер и это все. Довольно аскетичный набор для хакерстования! Достопочтенный debug.com для MS-DOS и тот был побогаче. Зато ALD бесплатен, распространяется в исходных текстах и грузит файлы без section table. Для обучения взлому он вполне подойдет, но на основной хакерский инструмент, увы, не тянет.

{{unix.binsrc_Image_1.png}}

**Рисунок 2 внешний вид отладчика ALD**

THE DUDE (http://the-dude.sourceforge.net/) – интересный source-level отладчик, работающий в обход ptrace и успешно работающий там, где gdb/ald уже не справляются. К сожалению, работает только под LINUX, а поклонникам остальных операционных систем остается сосать (лапу). Архитектурно стоит из трех основных частей: модуля ядра the_dude.o, реализующего низкоуровневые отладочные функции, спрягающей библиотечной обертки вокруг него – libduderino.soи внешнего пользовательского интерфейса – ddbg. Собственно говоря, пользовательский интерфейс лучше сразу переписать. Отладчик бесплатен, но для его скачивания требуется предварительная регистрация на www.sourcefogre.net

LINICE (http://www.linice.com/) – soft-ice под LINUX. Чрезвычайно мощный отладчик ядерного уровня, ориентированный на работу с двоичными файлами без исходников. Основной инструмент любого хакера, работающего под LINUX. В настоящее время работает с только на ядре версии 2.4 (и вроде бы – 2.2), но отваливается с ошибкой в файле Iceface.c при компиляции под все остальные. Добавляет устройство /dev/ice, чем легко выдает свое присутствие в системе (впрочем, благодаря наличию исходных текстов это не представляет серьезной проблемы). Всплывает по нажатию <CTRL>+<Q>, причем USB клавиатура пока не поддерживается. Загрузчика нет и не предвидится, поэтому единственным способом отладки остается внедрение машинной команды INT 03 (опкод CCh) в точку входа с последующим ручным восстановлением оригинального содержимого.

{{unix.binsrc_Image_2.jpg}}

**Рисунок 3 нет, это не сон, это soft-ice под LINUX!**

PICE (http://pice.sourceforge.net/) Экспериментальный ядерный отладчик для LINUX, работающий только в консольном режиме (т. е. без X'ов) и реализующий минимум функций. Тем не менее, и он на что-то может сгодиться.

**The x86 Emulator plugin for IDAPro**(http://ida-x86emu.sourceforge.net/) – эмулирующий отладчик, конструктивно выполненный в виде плагига для IDA Pro и распространяющийся в исходных текстах без предкомпиляции (а это значит, что кроме самой IDAPro еще понадобиться и SDK, нарыть которой намного труднее). Основное достоинство эмулятора в том, что он позволяет выполнять произвольные куски кода на виртуальном процессоре. Например, передавать управление процедуре проверки серийного номера/пароля, минуя остальной код. Такая техника совмещает лучшие черты статического и динамического анализа, значительно упрощая взлом заковыристых защит.

{{unix.binsrc_Image_3.jpg}}

**Рисунок 4 основная панель эмулятора**

==== дизассемблеры ====

IDA Pro (www.idapro.com) – лучший дизассемблер всех времен и народов теперь доступный и под LINUX! Поклонники же FreeBSD и остальных операционных систем могут довольствоваться консольной Windows-версией запущенной под эмулятором, или работать с ней непосредственно из-под MS-DOS, OS/2, Windows. До недавнего времени IDA Pro отказывалась дизассемблировать файлы без section table, однако, в последних версиях этот недостаток был устранен. Отсутствие приличных отладчиков под UNIX, превращает IDA Pro в основной инструмент взломщика.

{{unix.binsrc_Image_4.png}}

**Рисунок 5 консольная версия IDA Pro**

objdump – аналог dumpbin для ELF-файлов с простеньким дизассемблером внутри. Требует обязательного наличия section table, не переваривает искаженных полей, с упакованными файлами не справляется, тем не менее в отсутствие IDA Pro сгодится и она.

==== шпионы ====

truss – полезная утилита, штатным образом входящая в комплект поставки большинства UNIX'ов. Отслеживает системные вызовы (они же – syscall'ы) и сигналы (signals), совершаемые подопытной программой с прикладного уровня, что позволяет многое сказать о внутреннем мире защитного механизма.

<code>
mmap(0x0,4096,0x3,0x1002,-1,0x0)			 	= 671657984 (0x2808b000)
break(0x809b000)					 	= 0 (0x0)
break(0x809c000)					 	= 0 (0x0)
break(0x809d000)					 	= 0 (0x0)
break(0x809e000)					 	= 0 (0x0)
stat(".",0xbfbff514)					 	= 0 (0x0)
open(".",0,00)						 	= 3 (0x3)
fchdir(0x3)						 	= 0 (0x0)
open(".",0,00)						 	= 4 (0x4)
stat(".",0xbfbff4d4)					 	= 0 (0x0)
open(".",4,00)						 	= 5 (0x5)
fstat(5,0xbfbff4d4)					 	= 0 (0x0)
fcntl(0x5,0x2,0x1)					 	= 0 (0x0)
__sysctl(0xbfbff38c,0x2,0x8096ab0,0xbfbff388,0x0,0x0) 		= 0 (0x0)
fstatfs(0x5,0xbfbff3d4)				 		= 0 (0x0)
break(0x809f000)					 	= 0 (0x0)
getdirentries(0x5,0x809e000,0x1000,0x809a0b4)	 		= 512 (0x200)
getdirentries(0x5,0x809e000,0x1000,0x809a0b4)	 		= 0 (0x0)
lseek(5,0x0,0)						 	= 0 (0x0)
close(5)						 	= 0 (0x0)
fchdir(0x4)						 	= 0 (0x0)
close(4)						 	= 0 (0x0)
fstat(1,0xbfbff104)					 	= 0 (0x0)
break(0x80a3000)					 	= 0 (0x0)
write(1,0x809f000,158)					 	= 158 (0x9e)
exit(0x0)							process exit, rval = 0
</code>

**Листинг 1 образец отчета truss**

{{unix.binsrc_Image_5.png}}

**Рисунок 6 отслеживание syscall'ов с помощью truss**

ktrace – еще одна утилита из штатного комплекта поставки. Отслеживает системные вызовы, namei translation (синтаксический разбор имен), операции ввода-вывода, сигналы, userland-трассировку и переключение контекстов, совершаемого подопытной программой с ядерного уровня. Короче говоря, ktrace представляет собой улучшенный вариант truss, однако в отличии от последней выдает отчет не в текстовой, а двоичной форме и для генерации отчетов необходимо воспользоваться утилитой kdump.

<code>
  8259 ktrace   CALL  write(0x2,0xbfbff3fc,0x8)
  8259 ktrace   GIO   fd 2 wrote 8 bytes
       "ktrace: "
  8259 ktrace   RET   write 8
  8259 ktrace   CALL  write(0x2,0xbfbff42c,0x13)
  8259 ktrace   GIO   fd 2 wrote 19 bytes
       "exec of 'aC' failed"
  8259 ktrace   RET   write 19/0x13
  8259 ktrace   CALL  write(0x2,0xbfbff3ec,0x2)
  8259 ktrace   GIO   fd 2 wrote 2 bytes
       ": "
  8259 ktrace   RET   write 2
  8259 ktrace   CALL  write(0x2,0xbfbff3ec,0x1a)
  8259 ktrace   GIO   fd 2 wrote 26 bytes
       "No such file or directory
       "
  8259 ktrace   RET   write 26/0x1a
  8259 ktrace   CALL  sigprocmask(0x1,0x2805cbe0,0xbfbffa94)
  8259 ktrace   RET   sigprocmask 0
  8259 ktrace   CALL  sigprocmask(0x3,0x2805cbf0,0)
  8259 ktrace   RET   sigprocmask 0
  8259 ktrace   CALL  exit(0x1)
  8265 ktrace   RET   ktrace 0
</code>

**Листинг 2 образец отчета ktrace**

==== шестнадцатеричные редакторы ====

BIEW (http://belnet.dl.sourceforge.net/sourceforge/biew/biew562.tar.bz2) – HEX-редактор, дизассемблер, криптор и инспектор ELF-формата в одном флаконе. Встроенный ассемблер отсутствует, поэтому хачить приходится непосредственно в машинном коде, что напрягает, однако, другого выбора у нас нет (разве, что дописать ассемблер самостоятельно).

{{unix.binsrc_Image_6.png}}

**Рисунок 7 шестнадцатеричный редактор biew**

==== дамперы ====

В UNIX содержимое памяти каждого из процессоров представлено в виде набора файлов, расположенных в каталоге /proc. Здесь же хранится контекст регистров и все остальное. Однако, дамп памяти это еще не готовый ELF-файл и к непосредственному употреблению он не пригоден. Тем не менее, дизассемблировать его "сырой" образ вполне возможно.

===== автоматизированные средства защиты =====

Упаковщики исполняемых файлов используются не только для уменьшения размеров программы, но и для затруднения ее взлома. Под Windows такая мера никого надолго не остановит, вот UNIX – другое дело! Автоматических распаковщиков нет, дамперы и не ночевали, отлаживать нечем (особенно на не LINIX системах). Просто пропускаете файл через упаковщик и хрен кто его расковыряет. То есть, расковырять-то, конечно, смогут, но для этого хакеру понадобиться весьма веская мотивация, которой у него обычно нет.

Минус всех упаковщиков в том, что они серьезно снижают мобильность защищенной программы (в особенности, если содержат системно-зависимые антиотладочные приемы), к тому же все известные мне упаковщики нацелены исключительно на LINUX и не работают под FreeBSD и других UNIX клонах, хотя в написании такого упаковщика нет ничего невозможного.

shiva (http://www.securereality.com.au/) – самый мощный упаковщик из всех имеющихся, хотя и основан на морально устаревших идеях, известных Windows-программистам с незапамятных времен. Реализует многослойную модель шифровки по типу "лука" (onion's layer) или "матрешки", использует полиморфный движок, нашпигованный множеством антиотладочных и анти-дизассемблерных приемов, противодействует gdb и другим отладчикам, работающим через ptrace, успешно борется с strace/ltrace/fenris, а так же предотвращает снятие скальпа (э… дампа) программы через /proc. Подробности на blackhat'e: www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf. Вопреки  распространенному мнению о несокрушимости Шивы, для опытного хакера она непреграда, к тому же агрессивная природа упаковщика приводит к многочисленным проблемам, в частности перестает работать fork. Тем не менее, появление Шивы – большой шаг вперед и для защиты от начинающих хакеров это лучший выбор!

burneye (http://packetstormsecurity.nl/groups/teso/burneye-1.0.1-src.tar.bz2) – популярный, но не слишком стойкий упаковщик/протектор. Уже давно взломан и руководство по его преодолению в сети не найдет только ленивый. Вот только некоторые из них: www.securitylab.ru/tools/32046.html,www.activalink.net/index.php/BurnEye Encrypted Binary Analisis,http://www.incidents.org/papers/ssh_exploit.pdf. Использует крайне примитивный механизм определения отладчика – просто подает сигнал 5 (Trace/breakpoint trap), в отсутствии GDB или чего-то очень на него похожего передающий управление на специальную процедуру, увеличивающую значение "секретной" ячейки памяти на единицу, а в присутствии – вылетающий в отладчик. При наличии "правильного" отладчика, работающего в обход ptrace, типа THE DUDE или LINICE, ломается элементарно, хотя и не так быстро как хотелось бы (приходится продираться через тонны запутанного кода, напоминающего мычание обкуренной коровы с макового поля).Для защиты от невъедливого хакера bruneye вполне подходит, а большего нам зачастую и не надо!

624 (http://sed.free.fr/624/) – малоизвестный простенький упаковщик. Работает шесть дней в неделю по 24 часа, а в воскресенье отдыхает. Шутка! Тем не менее добавить его к своей коллекции все-таки стоит.

upx (http://upx.sourceforge.net/) – легендарный кросс-платформенный упаковщик, работающий на множестве платформ от Atari до LINUX'a. Никак не препятствует отладке и, что хуже всего, содержит встроенный распаковщик, позволяющий вернуть защищенный файл в первородный вид, однако, после небольшой доработки напильником (спасибо исходным текстам!), приобретает весь необходимый набор противохакерских методик. Намного лучше дорабатывать upx, чем использовать любой из существующих навесных протекторов, поскольку всякий клон upx'а приходится исследоваться индивидуально и хакер не может использовать общие схемы. Естественно, для модернизации упаковщика вам понадобятся антиотладочные приемы, о технике которых мы сейчас и поговорим.

===== антиотладочные приемы =====

Большинство антиотладочных приемов по своей природе системно-зависимы и препятствуют переносу защищенной программы на другие платформы, поэтому пользоваться ими следует с большой осторожностью и осмотрительностью, тщательно тестируя каждую строку кода.

==== паразитные файловые дескрипторы ====

В большинстве (если не во всех) UNIX'ах файл, запущенный нормальным образом, получает в свое распоряжение три дескриптора – 0 (stdin), 1 (stdout), 2 (stderr). GDB и подобные ему отладчики создают дополнительные дескрипторы и не закрывают их. Чтобы обнаружить отладчик достаточно попытаться закрыть дескриптор номер 3 и если эта операция завершится успешно, значит, нас отлаживают по полной программе!

Готовый пример реализации может выглядеть, например, так:

<code>
if (close(3)==-1) 
	printf ("all ok\n");
else
	printf ("fuck off,debugger!\n");
</code>

**Листинг 3 распознавание отладчика по паразитным дескрипторам**

{{unix.binsrc_Image_7.png}}

**Рисунок 8 капкан для debugger'а**

==== аргументы командной строки и окружение ====

Оболочка типа bash автоматически подставляет имя запускаемого файла в переменную окружения "_". Отладчики же оставляют ее пустой (см. таблицу 1). Наблюдаются некоторые различая и с нулевым аргументов командой строки – bash (и подавляющее большинство остальных оболочек) подставляет сюда текущее имя файла, а GDB – имя файла с полным путем (впрочем, ALD таким путем распознать не удается).

| |argv[0]|getenv("_")|
|shell|./file_name|./file_name|
|strace|./file_name|/usr/bin/strace|
|ltrace|./file_name|/usr/bin/ltrace|
|fenris| ./file_name|/usr/bin/fenris|
|gdb|/home/usr/file_name|(NULL)|
|acl|./file_name|(NULL)|

**Таблица 1 распознавание отладчика по параметрам командной строки и переменным окружения**

==== дерево процессов ====

В LINUX при нормальном исполнении программы идентификатор родительского процесса (ppid) всегда равен и идентификатору сессии (sid), а при запуске под отладчиком ppid и sid различны (см. таблицу 2). Однако, в других операционных системах (например, FreeBSD) это не так и sid отличается от  ppid даже вне отладчика. Как следствие, программа, защищенная по этой методике дает течь, отказываясь выполняться даже у честных пользователей.

Личное наблюдение – при нормальном исполнении программы под FreeBSD идентификатор текущего процесса существенно отличается от идентификатора родительского, а при запуске из-под отладчика идентификатор родительского процесса меньше ровно на единицу. Таким образом, законченный пример реализации может выглядеть так:

<code c>
main ()
{
	if ( (getppid() != getsid(0)) && ((getppid() + 1) != getppid())
		printf("fuck off, debugger!\n");
	else
		printf("all ok!\n");
}
</code>

**Листинг 4 определение отладчика по родословной процессоров**

| |shell|gdb|strace|ltrace|fenris|
|getsid|0x1968|0x1968|0x1968|0x1968|0x1968 |
|getppid|0x1968|0x3a6f|0x3a71|0x3a73|0x3a75 |
|getpgid|0x3a6e|0x3a70|0x3a71|0x3a73|0x3a75 |
|getpgrp|0x3a6e|0x3a70|0x3a71|0x3a73|0x3a75|

**Таблица 2 вариации идентификаторов в LINUX**

==== сигналы, дампы и исключения ====

Следующий прием основан на том факте, что большинство отладчиков жестко держат SIGTRAP-сигналы (trace/breakpoint trap) и не позволяют отлаживаемой программе устанавливать свои собственные обработчики. Как это можно использовать для защиты? Устанавливаем обработчик исключительной ситуации посредством вызова signal(SIGTRAP, handler) и спустя некоторое время выполняем инструкцию INT 03. При нормальном развитии событий управление получает handler, а при прогоне программы под GDB происходит аварийный останов с возвращением в отладчик. При возобновлении выполнения, программа продолжает исполняется с прерванного места, при этом handler управления так и не получает. Имеет смысл повесить на него расшифровщик или любую другую "отпирающую" процедуру.

Это очень мощный антиотладочный прием, единственный недостаток которого заключается в привязанности к конкретной аппаратной платформе – в данном случае платформе INTEL.

Конкретный пример реализации выглядит так:

<code c>
#include <signal.h>

void handler(int n) { /* обработчик исключения */ }

main()
{
	// устанавливаем обработчик на INT 03
	signal(SIGTRAP, handler);
	
	//…
	
	// вызываем INT 03, передавая управление handler'у
	// или отладчику (если он есть)
	__asm__("int3");
	
	// зашифрованная часть программы,
	// расшифровываемая handler'ом
	printf("hello, world!\n")
}
</code>

**Листинг 5 сигналы на службе контразветки**

==== распознавание программных точек останова ====

Программные точки останова (представляющее собой машинную команду INT 03h с опкодом CCh) распознаются тривиальной подсчетом контрольной суммы собственного тела. Поскольку порядок размещения функций в памяти в общем случае совпадает с порядком их объявления в исходном тесте, адрес конца функции равен указателю на начало следующей функции.

<code c>
foo() {/* контролируемая функция 1 */ }
bar() {/* контролируемая функция 1 */  }
main()
{
	int a; unsigned char *p; a = 0;
	for (p = (unsigned char*)foo; p < (unsigned char*)main; p++)
		a += *p;
	
	if (a != _MY_CRC)
		printf ("fuck off, debugger!\n");
	else
		printf ("all ok\n");
}
</code>

**Листинг 6 контроль целостности своего кода как средство обнаружения программных точек останова**

==== мы трассируем, нас трассируют… ====

Функцию ptrace нельзя вызывать дважды – попытка трассировки уже трассируемого процесса порождает ошибку. Это не ограничение библиотеки ptrace – это ограничение большинства процессорных архитектур (хотя на x86-процессорах можно и развернуться). Отсюда идея – делаем fork, расщепляя процесс на два и трассируем самого себя. Родителю достается PT_ATTACH (он же PTTRACE_ATTACH), а потомку – PT_TRACE_ME (он же PTTRACE_TRACE_ME). Чтобы хакер не прибил ptrace, в ходе трассировки рекомендуется делать что-то полезное (например, динамически расшифровать код), тогда для отладки такой программы будет возможна лишь на эмуляторе. 

Простейший пример реализации может выглядеть, например, так:

<code c>
int main()
{
	pid_t child; int status;
	switch((child = fork()))
	{
		case 0:					// потомок
			ptrace(PTRACE_TRACEME);
			// секретная часть
			exit(1);
		
		case -1:				// ошибка
			perror("fork"); exit(1);
		
		default:				// родитель
			if (ptrace(PTRACE_ATTACH, child))
			{
				kill(child, SIGKILL); exit(2);
			}
			while (waitpid(child, &status, 0) != -1)
			ptrace(PTRACE_CONT, child, 0, 0);
			exit(0);
	}
	return 0;
}
</code>

**Листинг 7 самотрассирующася программа**

==== прямой поиск отладчика в памяти ====

Всякий отладчик прикладного уровня может быть обнаружен тривиальным просмотром содержимого /proc. Хороший результат дает поиск по сигнатурам – текстовым строкам копирайтов конкретных отладчиков. Чтобы быть уверенным, что отлаживают именно нас, а не кого-то еще, можно сравнить идентификатор процесса отладчика (он совпадает с именем соответствующей директории в /proc) c идентификатором материнского процесса (его можно получить с помощью getppid), однако, если отладчик сделает attach на активный процесс эта методика не сработает. Однако, лучше не заметить отладчик, чем реагировать на отладку посторонних процессов.

{{unix.binsrc_Image_8.png}}

**Рисунок 9 в поисках отладчика**

==== измерение времени выполнения ====

Отладчики прикладного уровня не "замораживают" часы в процессе трассировки и потому замер времени между двумя соседними участками программы позволяет обнаружить как отладку, так и шпионаж за системными функциями посредством truss\ktrace.

===== заключение =====

Всякая защита лишь отодвигает взлом, но отнюдь не делает его невозможным. Однако, начиная с некоторого уровня сложности взлом становится нерентабельным и единственным стимулом хакера остается спортивный интерес, вызванный природным любопытством и желанием покопаться в интересной программе. Не стремитесь к элегантности! Используйте тошнотворный стиль кодирования, отвращающий хакера хуже горькой редьки. Тогда шансы программы на выживание значительно возрастут и долгое время она останется не взломанной.


