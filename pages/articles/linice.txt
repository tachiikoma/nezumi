====== основы термоядерной отладки с linice ======
<sub>{{linice.odt|Original file}}</sub>

крис касперски ака мыщъх, no-email

**достойных отладчиков ядерного уровня и под ****windows**** немного, а на ****linux**** их можно пересчитать по пальцам одной руки, да и те большей частью сырые, недоделанные или же позаброшенные, мхом позаросшие… сегодня мы поговорим о самом популярном и наиболее интересном из них — ****linice****.**

{{INLINETOC}}
===== введение =====

Как уже можно догадаться из названия, **linice** – это неофициальный "порт" легендарного soft-ice под linux, сохранивший интерфейс, систему команд и большинство возможностей последнего — всплытие по горячей клавише (в linice это <CTRL‑Q>), установка аппаратных точек останова на _все_ функции и системные вызовы, просмотр GDT/LDT/IDT, _физических_ страниц памяти, плюс возможности, позаимствованные из GDB (вызов произвольной функции командой CALL, сохранение/восстановление контекста регистров, внутренние переменные и т. д.).

В отличии от большинства других отладчиков, работающих через нереентерабельный и легко обнаруживаемый защитами механизм ptrace (windows-аналогом которого является DEBUG_PROCESS, используемый прикладными отладчиками), linice использует "нативную" трассировку, такую же как в soft-ice, что позволяет обоим отладчикам отлаживать круто защищенные программы, с которыми другие уже не справляются.

{{linice_Image_0.png}}

**Рисунок 1 внешний вид отладчика linice**

На самом деле это никакой не порт (отсюда и кавычки), а независимый проект, написанный с нуля и распространяющийся в исходных текстах на бесплатной основе (от soft-ice там только вдохновение). Основная часть кода, предназначенная для 2.4 ядра, была написана немецким хакером Гораном Девиком (GoranDevic, <author@linice.com>), однако, поддержкой 2.6 ядра занимались уже совсем другие люди: DanielReznick, PeterK. и CarlosManuelDuclosVergara. А наш соотечественник — Олег Худаков — переписал ассемблерные файлы с NASM'а на GCC.

Исходные тексты лежат на официальном сайте проекта — http://www.linice.com, там же находится документация, короткий FAQ и ссылка на форум http://groups.google.com/group/linice, насчитывающий 35 зарегистрированных участников и 33 топика, последний из которых датирован 12 июнем 2006 года (т. е. имеет возраст свыше трех месяцев). Готовые бинарные сборки отсутствуют.

{{linice_Image_1.png}}

**Рисунок 2 официальный сайт linice**

Создатели проекта открыли свой собственный аккаунт на sourceforge, но поленились выложить на него какие бы то ни было файлы, предоставив на обозрение всего лишь 3 screenshot'а весьма похабного качества: https://sourceforge.net/projects/linice

{{linice_Image_2.png}}

**Рисунок 3 linice на sourceforge**

===== системные требования =====

Последняя версия linice носит номер 2.6 и датируется 28 июлем 2005 года, полностью поддерживая 2.4.xlinux-ядро и консольный VGA-режим. С более новыми ядрами наблюдаются серьезные проблемы и 2.6.x ядро поддерживается лишь в ограниченном режиме.

Отладчик разрабатывался и тестировался под Debian 2.6, совместимость с остальными дистрибутивами не гарантируется, вынуждая прибегать к бубну, но не в некоторых случаях не помогает и бубен. Вообще-то, держать на своей машине Debian только для того, чтобы работать с linice – это вполне нормально. Давным-давно, когда реализации soft-ice для NT еще не существовало, многие хакеры инсталлировали 9x только для того, чтобы ломать программы, хотя сами сидели под NT.

Поскольку, охватить все тонкости установки linice в рамках одной статьи практически нереально, мыщъх ограничится описанием процесса компиляции и запуска linice под одним конкретным дистрибутивом KNOPPIX 3.7 с ядром 2.4.1 в консольном VGA-режиме.

{{linice_Image_3.jpg}}

**Рисунок 4 дистрибутив KNOPPIX'а, совместимый с linice**

linice поддерживает ACPI и многопроцессорные машины, но плохо дружит с X'ми, особенно на видео-картах отличных от nVIDIA, а в 24-битную глубину цветности он вообще не врубается, "переваривая" только 8-, 16- и 32 бит/на пискельные режимы, поэтому, отладку X-приложений удобнее вести через удаленный терминал, подключенный по COM-порту по протоколу VT100, при этом локальная клавиатура так же будет работать с linice!

Кстати, о клавиатурах. Поскольку, linice взаимодействует с оборудованием напрямую, то USB-клавиатуры им не поддерживается (разработчикам было лень тащить за собой USB-стек). Используйте стандартную PS/2 (DIN) клавиатуру, а если таковой не имеется — выключите поддержку всех USB-устройств в linux'е, заставляя BIOS эмулировать PS/2 клавиатуру, понятную linice.

Под виртуальными машинами (и, в частности, VM Ware 4.5) linice либо вообще не загружается, либо загружается, но не реагирует на клавиатуру, либо срывает виртуальной машине крышу, вынуждая нас работать на "живом" железе, что не есть хорошо, однако, технологии эмуляции непрерывно совершенствуется и есть надежда, что через некоторое время эта проблема будет решена.

{{linice_Image_4.png}}

**Рисунок 5 реакция VMWare на попытку запуска linice**

===== компиляция и конфигурирование linice =====

Скачиваем gzip-архив исходных текстов http://www.linice.devic.us/linice-2.6.tar.gz, занимающий чуть меньше мегабайта, распаковываем его на диск, заходим в каталог ./docs, вникаем в readme откуда узнаем, что сборка отладчика под 2.4 ядро осуществляется так:

<code>
# cd build
# ./make_bin-2.4
# cd ../bin
# make clean ; make
</code>

**Листинг 1 сборка linice под 2.4 ядро**

Однако, перед запуском make необходимо открыть файл ./bin-2.4/Makefile и отредактировать строку "TARGET" в соответствии с конфигурацией и архитектурой целевой платформы. В частности, на ACPI-машинах с многоядерными или HyperThreading-процессорами она будет выглядеть так:

<code>
TARGET = -DSMP -DIO_APIC
</code>

**Листинг 2 конфигурирование отладчика**

После завершения компиляции в каталоге ./bin появятся множество файлов и каталогов, но значимыми из них являются только: **lin****s****ym** – загрузочный модуль отладчика, **linince****.****dat** – файл конфигурации, **xice** – поддержка X'ов, при работе в текстовом режиме его можно удалить; **./****linice****_2.4.27/****linice****.****o** – загружаемый модуль ядра, содержащий непосредственно сам отладчик.

Собрав минимально работающий комплект, неплохо бы дособирать и все остальное — демонстрационные отладочные примеры, находящиеся в каталоге ./test и компилируемые скриптом compile, а так же модуль расширения (по-нашему плагин), лежащий в каталоге ./ext, собираемый командой make и загружаемый командой insmod. Никакой пользы от него нет, но изучив исходный текст, мы сможем писать свои собственные модули, расширяющие функциональность linice.

{{linice_Image_5.png}}

**Рисунок 6 процесс сборки linice**

===== загрузка системы и запуск отладчика =====

При загрузки KNOPPIX'а cLiveCD в нижней строке экрана появляется приглашение "boot:" где необходимо ввести "**knoppix ****2**** vga****=****normal**". Cheat-код "knoppix" выбирает ядро 2.4 (автоматически загружаемое по умолчанию, поэтому "knoppix" можно опустить), "2" – блокирует загрузку X'ов, а "vga=normal" устанавливает стандартный vga режим с разрешением 80x25.

{{linice_Image_6.png}}

**Рисунок 7 загрузка KNOPPIX'а с LiveCD**

Дождавшись завершения загрузки, говорим "su", затем "passwd" и вводим новый пароль для root'a, под которым тут же заходим в систему, воспользовавшись командой "login". Если этого не сделать, попытка запуска linice закончится сокрушительным провалом с воплем о "segmentation fault".

{{linice_Image_7.png}}

**Рисунок 8 загрузка KNOPPIX'а с жесткого диска**

При загрузке KNOPPIX'а с жесткого диска (на который его можно установить командой "sudo knoppix-installer", набранной в окне терминала из-под LiveCD сессии), появится стартовое меню со списком доступных ядер. Выбираем "Linux(2.4)-1" и нажимаем <TAB> для задания параметров загрузки: "** 2 ****vga****=****normal**". Слово "knoppix" писать не нужно, поскольку ядро уже выбрано и так. После завершения загрузки даем команду "login" и входим в систему под root'ом (предполагается, что аккаунт был создан ранее).

{{linice_Image_8.png}}

**Рисунок 9  KNOPPIX, загруженный без X'ов в консольном VGA-режме**

Запуск отладчика осуществляется командой "./linsym -i", после чего отладчик немедленно появляется на экране. Если же этого не происходит, попробуйте указать ключ "‑‑verbose 3" для вывода диагностических сообщений.

{{linice_Image_9.png}}

**Рисунок 10 процедура запуска отладчика**

Одной из причин отказа в загрузке может быть отсутствие файла /boot/System.map, содержащего адреса ядерных функций. Загрузка провалится и в том случае, если содержимое System.map не соответствует текущему ядру, что может произойти, например, при его рекомпиляции. Некоторые составители дистрибутивов либо вообще не включают System.map (полагая, что это усилит безопасность системы, т. к. rootkit'ам будет сложнее осуществить перехват syscall'ов), либо кладут сюда что-то совершенно левое и вообще непонятно откуда взятое. В таких случаях достаточно просто перекомпилировать ядро, указав отладчику путь к файлу System.map с помощью ключа "-m", если он расположен не в /boot, а где-нибудь в другом месте. Таким образом и безопасность не пострадает и linice сможет работать!

{{linice_Image_10.png}}

**Рисунок 11 linice запущенный в консольном VGA режиме**

Возврат из отладчика в систему происходит по <F5> или команде "x <ENTER>". Комбинация <CTRL-Q> вызывает отладчик из любой программы, однако, вовсе не факт, что мы очутимся в ее контексте, ведь linux — многозадачная система, переключающая процессы один за другим, а команды "ADDR" (переключающей контексты) в "лексиконе" linice все еще не существует и когда она появится — неизвестно, поэтому приходится хитрить, устанавливания точки останова на системные вызовы, используемые конкретной программой или врываясь в процесс по методу INT 03h, о чем мы сейчас и поговорим.

За выгрузку отладчика (если его действительно хочется выгрузить) отвечает ключ "-x", переданный все тому же linsym'у.

===== основы работы с linice =====

Для тех, кто уже работал с soft-ice, освоение linice не представит никакой проблемы. Здесь используются все те же команды: "D" – дамп памяти, "E" – редактирование памяти, "T" – пошаговая трассировка, "P" – трассировка без захода в функции, "R" – просмотр/модификация регистров, "BPM/BPX" – установка точки останова на доступ/исполнение памяти и т. д. Полный перечень команд содержится как во встроенной справке, вызываемой по "HELP" (причем, "HELP имя_команды" выдает дополнительную информацию по команде), так и в штатной документации.

Давайте нажмем <CTRL-Q> и пороемся в списке процессов, выводимых на экран командой "PROC", причем текущий процесс выделяется голубым цветом:

<code>
:PROC
PID	TSS	Task	state		uid	gid	name
   1	0000 C1C3E000	SLEEPING	0	0	init
   2	0000 F7EE8000	SLEEPING	0	0	keventd
   3	0000 F7EE2000	SLEEPING	0	0	ksoftirqd_CPU0
   4	0000 F7EE0000	SLEEPING	0	0	ksoftirqd_CPU1
   5	0000 F7ED0000	SLEEPING	0	0	kswapd
   6	0000 F7EAA000	SLEEPING	0	0	bdflush
   7	0000 F7EA8000	SLEEPING	0	0	kupdated
  56	0000 F6A36000	SLEEPING	0	0	kjournald
1006	0000 F7A34000	RUNNING		0	0	automount
1013	0000 F68E6000	SLEEPING	0	0	cupsd
…
1105	0000 F6DDE000	SLEEPING	0	0	mc
1106	0000 F6DD4000	SLEEPING	0	0	cons.saver
</code>

**Листинг 3 вывод списка процессов на экран**

Процессы это, конечно, хорошо, но как же все-таки нам отлаживать программы? Самое простое – воткнуть в точку входа машинную команду CCh, соответствующую инструкции INT 03h, предварительно записав содержимое оригинального байта. Это можно сделать любым hex-редактором, например, неоднократно упоминаемом мыщъх'ем HTE.

{{linice_Image_11.png}}

**Рисунок 12 втыкаем CCh в начало файла в hex-редакторе HTE**

Загрузив файл в редактор, нажимаем <F6> (mode), выбираем elf/image, подгоняем курсор к "entrypoint:", давим <F4> (edit) и, изменяем первый байт на CCh, сохраняем изменения по <F2> (save) и выходим. При запуске пропатченной программы linice немедленно всплывает, потревоженный исключением, сгенерированным CCh, после которого EIP указывает на конец CCh.

<code>
0023:080482C0	CC	int	3
0023:080482C1	ED	in	eax, dx
0023:080482C2	5E	pop	esi
0023:080482C3	89E1	mov	ecx, esp
</code>

**Листинг 4 состояние программы, c пропатченной точкой входа, в момент всплытия отладчика**

Курсор указывает на инструкцию "in eax,dx" (EDh), представляющую собой "осколок" от пропатченной команды "xor ebp,ebp" (31h EDh). Теперь (по идее) мы должны восстановить оригинальный байт, заменив CCh на 31h, уменьшить регистр EIP на единицу и продолжать трассировку в обычном реже.

Да вот не тут-то было!!! linice это, конечно, порт, но… только очень сырой и модифицировать память страничного имиджа он _не_ умеет, даже если предварительно открыть кодовый сегмент на запись. Ни "E" (редактирование), ни "F" (заполнение), ни "M" (копирование памяти) _не_ работают!!! Зато работает запись в стек и нам, хакерам, этого вполне достаточно.

Запоминаем текущее значение регистра EIP, копируем пропатченную машинную команду на вершину стека, восстанавливаем там байт CCh, передаем на нее управление, меняя значение EIP, выполняем ее, совершив единичный акт трассировки и возвращаем EIP на место, то есть на _следующую_ машинную команду:

<code>
:? eip					; узнаем EIP
Hex=080482C1	Dec=0134513345

; смотрим, что находится на вершине стека (из чистого любопытства)
:d esp-10
0018:BFFFEFC0 C0 82 04 08 00 00 00 00 5D 0C 00 40 DC EF FF BF

; копируем пропатченную машинную команду на вершину стека
; число 10h - максимально возможный размер машинной команды на x86
:m eip-1 L 10 esp-10

; смотрим как изменился стек
:d esp-10
0018:BFFFEFC0 CC ED 5E 89 E1 83 E4 F0 50 54 52 68 F0 85 04 08

; ага! стек действительно изменился, самое время править CCh на 31h
:e esp-10 31
Edit immediate data not implemented yet.
; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
; опс! непосредственное присвоение данных в linice не реализовано
; но мы можем отредактировать дамп в интерактивном режиме (так же как в soft-ice)
; или дать команду "F esp-10 L 1 31", только имейте ввиду, что в отличии от soft-ice
; отладчик linice _не_ обновляет окно дампа, поэтому, после выполнения команды F
; может показаться, что результата нет, на самом деле это не так, стоит только
; обновить дамп командой "D esp-10" и все встанет на свои места

; передаем управление на команду, скопированную в стек
:r eip (esp-10)
reg: eip = BFFFEFC0
; запоминаем это значение регистра EIP

:t					; совершаем единичный акт трассировки
0023:BFFFEFC2  5E		pop	esi
;    ^^^^^^^^
; как мы видим регистр EIP увеличился на 2 (BFFFEFC2h - BFFFEFC0h) = 02h
; следовательно адрес следующей команды равен: 080482C1h - 01h + 02h = 080482C2h,
; где 080482C1h — начальное значение EIP при входе в программу, а 01h - размер INT 03h

:r eip 80482C2	; устанавливаем EIP на команду, следующую за пропатченной инструкцией
reg: eip = 80482C2

; - - - продолжаем трассировку в обычном режиме - - -
</code>

**Листинг 5 восстановление оригинального байта, замененного инструкцией INT 03h**

Вот такие пляски с бубном устраивать приходится. А что поделаешь?! Ладно, с загрузкой программ в отладчик мы разобрались, теперь растерзаем точки останова на системные вызовы и ядерные функции.

Команда "exp" выводит имена, экспортируемые ядром (см. листинг 6), любое из которых может непосредственно фигурировать в выражениях, например, "bpx do_bkr" эквивалентно "bpx C012C9E8":

<code>
:exp
kernel
	C0320364	mmu_cr4_features
	C02AC3A4	acpi_disabled
	C02AC8A0	i8253_lock
	…
	C012BDA8	do_mmap_pgoff
	C012C764	do_munmap
	C012C9E8	do_brk
	C011E990	exit_mm
	C011E69C	exit_files
</code>

**Листинг 6 вывод имен, экспортируемых ядром**

С системными вызовами приходится сложнее. Непосредственной поддержки со стороны linice здесь нет (а ведь ей полагается быть, учитывая специфику linux), поэтому эту штуку приходится делать руками и хвостом.

**Таблица системных вызов, как известно, представляет собой массив двойных слов, начинающийся с адреса sys_call_table (эта переменная экспортируется ядром).**

<code>
:dd 			; переводим отладчик в режим отображения двойных слов
:d sys_call_table	; выводим таблицу на экран
0018:C02AB6A8 C0126ACC F8932650 F89326A0 C013DC10
0018:C02AB6B8 C013DD18 C013D5C8 C013D724 C011F3BC
0018:C02AB6C8 C013D664 C014A8E0 C014A3B4 F893020C
</code>

**Листинг 7 таблица системных вызовов**

Каждый элемент таблицы соответствует своему системному вызову, а каждый вызов имеет свой номер, который можно узнать заглянув в файл /usr/include/sys/syscall.h, но лучше это делать не под linux, где никаких непосредственных номеров нет, а позаимствовать тот же самый файл из BSD – все равно номера основных системных вызовов на всех системах совпадают. В частности, системный вызов open проходит под номером 5.

{{linice_Image_12.png}}

**Рисунок 13 номера системных вызовов**

Чтобы установить точку останова на "open" необходимо узнать его адрес, находящийся в 5'ом двойном слове таблицы системных вызов, считая от нуля и равный (в данном случае) C013D5C8h.

<code>
:bpx C013D5C8	; устанавливаем точку останова на системный вызов open
:x		; выходим из отладчика
…
# открываем какой-нибудь файл
…
:Breakpoint due to BPX 01
; ^^^^^^^^^^^^^^^^^^^^^^^
; отладчик тут же всплывает, сообщая нам об этом

:proс		; даем команду proc, чтобы убедиться, что мы вклинились в свой процесс
PID	TSS	Task		state		uid	gid	name
1049	0000	F6364000	SLEEPING	0	0	getty
1145	0000	F61CC000	SLEEPING	0	0	mc
1146	0000	F614A000	SLEEPING	0	0	cons.saver
</code>

**Листинг 8 установка точки останова на системный вызов open**

Таким путем легко "вклиниваться" в уже запущенные процессы, устанавливая точки останова на используемые ими системные вызовы, а так же совершать множество других вещей, жизненно важных для взлома.

===== заключение =====

Несмотря на свою откровенную сырость, linice вполне пригоден для отладки защищенных приложений, хотя сплошь и рядом приходится прибегать к обходным решениям, которые в нормальных отладчиках осуществляются на автомате. Поэтому, linice отнюдь не заменяет gdb, а всего лишь дополняет его.


